#!groovy


def upstream = !currentBuild.getBuildCauses('hudson.model.Cause$UserIdCause')
def buildtype = upstream ? "RecurringRun" : "AdHoc"
def branch = "master"
if ("${env.branch}" != "null" && "${env.branch}" != "") {
  branch = "${env.branch}"
}

# QA_INFRA_REPO should be set to the path of qa-infra-automation repo
QA_INFRA_REPO="${env.QA_INFRA_REPO:-${WORKSPACE}/qa-infra-automation}"

node {
  wrap([$class: 'AnsiColorBuildWrapper', 'colorMapName': 'XTerm', 'defaultFg': 2, 'defaultBg':1]) {
    withFolderProperties {
      paramsMap = []
      params.each {
        paramsMap << "$it.key=$it.value"
      }
      withCredentials([ string(credentialsId: 'AWS_ACCESS_KEY_ID', variable: 'AWS_ACCESS_KEY_ID'),
                        string(credentialsId: 'AWS_SECRET_ACCESS_KEY', variable: 'AWS_SECRET_ACCESS_KEY'),
                        string(credentialsId: 'AZURE_AKS_SUBSCRIPTION_ID', variable: 'AZURE_AKS_SUBSCRIPTION_ID'),
                        string(credentialsId: 'AZURE_CLIENT_ID', variable: 'AZURE_CLIENT_ID'),
                        string(credentialsId: 'AZURE_CLIENT_SECRET', variable: 'AZURE_CLIENT_SECRET'),
                        string(credentialsId: 'GKE_SERVICE_ACCOUNT', variable: 'GKE_SERVICE_ACCOUNT'),
                        string(credentialsId: 'PERCY_TOKEN', variable: 'PERCY_TOKEN')
                        ]) {
        withEnv(paramsMap) {
            stage('Checkout') {
            deleteDir()
            checkout([
                        $class: 'GitSCM',
                        branches: [[name: "*/${branch}"]],
                        extensions: scm.extensions + [[$class: 'CleanCheckout']],
                        userRemoteConfigs: scm.userRemoteConfigs
                    ])
            }
            try {
              stage('Run Tests') {
                sh 'pwd'
                sh 'ls -al cypress/jenkins'
                sh 'cypress/jenkins/init.sh'
              }
            } catch (err) {
                echo "Error: " + err
                currentBuild.result = 'FAILURE'
                error()
            }
            try {
              stage('Grab Results') {
                  sh "cypress/jenkins/scpget.sh dashboard/results.xml"
                  sh "cypress/jenkins/scpget.sh dashboard/cypress/reports/html/* html"
              }
            } catch(err) {
                echo "Error: " + err
                currentBuild.result = 'FAILURE'
            }
            if ("${env.CLEANUP}".toLowerCase() == "true") {
                try {
                  stage('Clean Test Environment') {
                    // Cleanup is handled by Ansible playbook
                    // If ansible-output.yaml exists, use it to determine what to clean up
                    sh """
                      if [ -f "${WORKSPACE}/ansible-output.yaml" ]; then
                        echo "Cleaning up infrastructure created by Ansible..."
                        # Call Ansible cleanup playbook if it exists
                        if [ -f "${QA_INFRA_REPO}/ansible/dashboard-tests/cleanup-playbook.yml" ]; then
                          ansible-playbook \\
                            -i "${QA_INFRA_REPO}/ansible/dashboard-tests/inventory-template.yml" \\
                            "${QA_INFRA_REPO}/ansible/dashboard-tests/cleanup-playbook.yml" \\
                            -e "@${WORKSPACE}/ansible-output.yaml"
                        else
                          echo "Cleanup playbook not found. Manual cleanup may be required."
                        fi
                      else
                        echo "No ansible-output.yaml found. Nothing to clean up."
                      fi
                    """
                  }
                } catch(err) {
                  echo "Error during cleanup: " + err
                  currentBuild.result = 'FAILURE'
                }
            }
            try {
              stage('Test Report') {
                  step([$class: 'JUnitResultArchiver', testResults: '**/results.xml'])
                  sh "pwd && ls -al && ls -al cypress"
                  publishHTML(target : [allowMissing: false,
                    alwaysLinkToLastBuild: true,
                    keepAll: true,
                    // The path is relative to ${WORKSPACE}
                    reportDir: 'html',
                    reportFiles: 'index.html',
                    reportName: 'html-report',
                    reportTitles: 'Report'])
              }
            }
            catch(err) {
              echo "Error: " + err
              currentBuild.result = 'FAILURE'
            }
            if ("${env.QASE_REPORT}".toLowerCase() == "true") {
                try {
                  stage('Publish to TC Management') {
                    withCredentials([ string(credentialsId: 'QASE_AUTOMATION_TOKEN', variable: 'QASE_AUTOMATION_TOKEN')]) {
                      withEnv(["BUILDTYPE=${buildtype}"]) {
                        sh "cypress/jenkins/transform-junit.sh"
                      }
                    }
                }
                } catch(err) {
                    echo "Error: " + err
                    currentBuild.result = 'FAILURE'
                }
            }
        }
      }
    }
  }
}