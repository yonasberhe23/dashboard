#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const xml2js = require('xml2js');

/**
 * Test Result Analyzer for Jenkins
 *
 * Features:
 * - Parse JUnit XML and HTML reports
 * - Analyze current test run failures
 * - Report only 1st failure when 3rd attempt fails
 * - Cost savings by reducing screenshots
 */

class TestResultAnalyzer {
  constructor(options = {}) {
    this.junitPath = options.junitPath || './'; // Look in workspace root
    this.htmlPath = options.htmlPath || 'html/';
  }

  /**
   * Parse JUnit XML results
   */
  async parseJUnitResults() {
    const junitFiles = this.findJUnitFiles();
    const firstFailures = new Map(); // Track first failure per test

    for (const file of junitFiles) {
      try {
        const xmlContent = fs.readFileSync(file, 'utf8');
        const parser = new xml2js.Parser();
        const result = await parser.parseStringPromise(xmlContent);

        if (result.testsuites && result.testsuites.testsuite) {
          const testSuites = Array.isArray(result.testsuites.testsuite) ? result.testsuites.testsuite : [result.testsuites.testsuite];

          for (const suite of testSuites) {
            if (suite.testcase) {
              const testCases = Array.isArray(suite.testcase) ? suite.testcase : [suite.testcase];

              for (const testCase of testCases) {
                const failure = testCase.failure && testCase.failure[0];

                if (failure) {
                  const testKey = `${ suite.$.name }:${ testCase.$.name }`;

                  // Only keep the first failure for each test
                  if (!firstFailures.has(testKey)) {
                    firstFailures.set(testKey, {
                      suite:   suite.$.name,
                      test:    testCase.$.name,
                      failure: {
                        message: failure.$.message,
                        type:    failure.$.type,
                        details: failure._
                      },
                      timestamp: new Date().toISOString(),
                      runId:     this.extractRunId(file)
                    });
                  }
                }
              }
            }
          }
        }
      } catch (error) {
        console.error(`Error parsing ${ file }:`, error.message);
      }
    }

    // Convert Map values to array
    return Array.from(firstFailures.values());
  }

  /**
   * Parse HTML reports for additional context
   */
  async parseHTMLReports() {
    const htmlFiles = this.findHTMLFiles();
    const reports = [];

    for (const file of htmlFiles) {
      try {
        const htmlContent = fs.readFileSync(file, 'utf8');
        // Extract test results from HTML (simplified parsing)
        const testResults = this.extractTestResultsFromHTML(htmlContent);

        reports.push({
          file,
          results: testResults
        });
      } catch (error) {
        console.error(`Error parsing HTML ${ file }:`, error.message);
      }
    }

    return reports;
  }

  /**
   * Generate detailed failure report
   */
  generateFailureReport(failure) {
    let report = `## Test Failure Details\n\n`;

    report += `**Test:** ${ failure.test }\n`;
    report += `**Suite:** ${ failure.failure.suite }\n`;
    report += `**Failure Type:** ${ failure.failure.type }\n`;
    report += `**Timestamp:** ${ failure.timestamp }\n`;
    report += `**Run ID:** ${ failure.runId }\n\n`;

    report += `## Error Message\n\`\`\`\n${ failure.failure.message }\n\`\`\`\n\n`;

    if (failure.failure.details) {
      report += `## Error Details\n\`\`\`\n${ failure.failure.details }\n\`\`\`\n\n`;
    }

    report += `## Context\n`;
    report += `- This failure was detected in Jenkins automated test run\n`;
    report += `- Generated by Test Result Analyzer\n`;
    report += `- Jenkins Build: ${ process.env.BUILD_NUMBER || 'Unknown' }\n`;
    report += `- Branch: ${ process.env.BRANCH_NAME || 'Unknown' }\n`;

    return report;
  }

  /**
   * Main analysis function
   */
  async analyzeResults() {
    console.log('üîç Starting Test Result Analysis...\n');

    // Parse current results
    const failures = await this.parseJUnitResults();

    console.log(`üìä Found ${ failures.length } test failures in current run (first failures only)`);

    // Generate detailed reports for each failure
    console.log('\nüìã First Failure Analysis:');
    console.log('='.repeat(50));

    for (const failure of failures) {
      console.log(`\n‚ùå FIRST FAILURE: ${ failure.test }`);
      console.log(`Suite: ${ failure.failure.suite }`);
      console.log(`Type: ${ failure.failure.type }`);
      console.log(`Message: ${ failure.failure.message }`);
    }

    // Generate summary report
    console.log('\nüìà Analysis Summary:');
    console.log('='.repeat(50));
    console.log(`- Total first failures: ${ failures.length }`);

    if (failures.length > 0) {
      console.log('\nüö® First Failures Requiring Attention:');
      failures.forEach((failure, index) => {
        console.log(`${ index + 1 }. ${ failure.test }`);
      });
    }

    // Save detailed report to file
    await this.saveDetailedReport(failures);

    return {
      failures,
      totalFailures: failures.length
    };
  }

  /**
   * Save detailed analysis report to file
   */
  async saveDetailedReport(failures) {
    const reportDir = 'html'; // Save to html directory for Jenkins publishing
    const reportFile = `${ reportDir }/test-analysis-${ Date.now() }.md`;

    // Ensure report directory exists
    if (!fs.existsSync(reportDir)) {
      fs.mkdirSync(reportDir, { recursive: true });
    }

    let report = `# Test Result Analysis Report\n\n`;

    report += `**Generated:** ${ new Date().toISOString() }\n`;
    report += `**Build:** ${ process.env.BUILD_NUMBER || 'Unknown' }\n`;
    report += `**Branch:** ${ process.env.BRANCH_NAME || 'Unknown' }\n\n`;

    report += `## Summary\n\n`;
    report += `- **Total Failures:** ${ failures.length }\n\n`;

    if (failures.length > 0) {
      report += `## ‚ùå Test Failures\n\n`;
      failures.forEach((failure, index) => {
        report += `### ${ index + 1 }. ${ failure.test }\n\n`;
        report += this.generateFailureReport(failure);
        report += '\n---\n\n';
      });
    }

    fs.writeFileSync(reportFile, report);
    console.log(`üìÑ Detailed report saved to: ${ reportFile }`);
  }

  // Helper methods
  findJUnitFiles() {
    const junitDir = path.resolve(this.junitPath);

    if (!fs.existsSync(junitDir)) {
      return [];
    }

    return fs.readdirSync(junitDir)
      .filter((file) => file.endsWith('.xml'))
      .map((file) => path.join(junitDir, file));
  }

  findHTMLFiles() {
    const htmlDir = path.resolve(this.htmlPath);

    if (!fs.existsSync(htmlDir)) {
      return [];
    }

    return fs.readdirSync(htmlDir)
      .filter((file) => file.endsWith('.html'))
      .map((file) => path.join(htmlDir, file));
  }

  extractRunId(filename) {
    const match = filename.match(/junit-([^.]+)\.xml/);

    return match ? match[1] : 'unknown';
  }

  extractTestResultsFromHTML(htmlContent) {
    // Simplified HTML parsing - could be enhanced
    const results = [];
    const testMatches = htmlContent.match(/<div[^>]*class="[^"]*test[^"]*"[^>]*>([^<]+)<\/div>/g);

    if (testMatches) {
      testMatches.forEach((match) => {
        const testName = match.replace(/<[^>]*>/g, '').trim();

        if (testName) {
          results.push({ name: testName });
        }
      });
    }

    return results;
  }
}

// CLI interface
if (require.main === module) {
  const analyzer = new TestResultAnalyzer();

  analyzer.analyzeResults()
    .then((results) => {
      console.log('\nüéâ Analysis complete!');
      process.exit(0);
    })
    .catch((error) => {
      console.error('‚ùå Analysis failed:', error);
      process.exit(1);
    });
}

module.exports = TestResultAnalyzer;
